//
// Author:
//   Aaron Bockover <aaron@abock.dev>
//
// Copyright 2020 Aaron Bockover.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Net.Http;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

static class MappingGenerator
{
    static async Task<int> Main(string[] args)
    {
        if (args.Length == 0)
        {
            Console.Error.WriteLine("usage: ecoji-gen OUTPUT_FILE");
            return 1;
        }

        using var writer = new StreamWriter(args[0]);
        await GenerateAsync(writer);
        return 0;
    }

    static async Task GenerateAsync(
        TextWriter writer,
        CancellationToken cancellationToken = default)
    {
        var emojis = await ParseAsync(cancellationToken);

        var padding41 = emojis[256]; emojis.RemoveAt(256);
        var padding42 = emojis[512]; emojis.RemoveAt(512);
        var padding43 = emojis[768]; emojis.RemoveAt(768);

        writer.WriteLine($"// AUTOGENERATED DO NOT EDIT! {DateTime.Now:o}"); 
        writer.WriteLine();
        writer.WriteLine("using System.Collections.Generic;");
        writer.WriteLine();
        writer.WriteLine("public static partial class Ecoji");
        writer.WriteLine("{");
        writer.WriteLine("    // This should sort before everything.");
        writer.WriteLine("    // This is output when 3 or less input bytes are present.");
        writer.WriteLine("    static readonly int padding = 0x2615;");
        writer.WriteLine();
        writer.WriteLine("    // The following paddings are used when only 4 of 5 input bytes are present.");
        writer.WriteLine();
        writer.WriteLine("    // This should sort between padding and emojis[0]");
        writer.WriteLine("    static readonly int padding40 = 0x269C;");
        writer.WriteLine();
        writer.WriteLine("    // This should sort between emojis[255] and emojis[256]");
        writer.WriteLine($"    static readonly int padding41 = 0x{padding41.Rune:X};");
        writer.WriteLine();
        writer.WriteLine("    // This should sort between emojis[511] and emojis[512]");
        writer.WriteLine($"    static readonly int padding42 = 0x{padding42.Rune:X};");
        writer.WriteLine();
        writer.WriteLine("    // This should sort between emojis[767] and emojis[768]");
        writer.WriteLine($"    static readonly int padding43 = 0x{padding43.Rune:X};");
        writer.WriteLine();

        writer.WriteLine("    static readonly int[] emojis = new int[]");
        writer.WriteLine("    {");
        for (int i = 0; i < 1024; i++)
            writer.WriteLine($"        0x{emojis[i].Rune:X}, // {emojis[i].Emoji}");
        writer.WriteLine("    };");

        writer.WriteLine();
        writer.WriteLine("    static readonly Dictionary<int, int> revEmojis = new Dictionary<int, int>");
        writer.WriteLine("    {");
        for (int i = 0; i < 1024; i++)
            writer.WriteLine($"        [0x{emojis[i].Rune:X}] = {i}, // {emojis[i].Emoji}");
        writer.WriteLine("    };");
        writer.WriteLine("}");
    }

    async static Task<List<(int Rune, string Emoji)>> ParseAsync(
        CancellationToken cancellationToken)
    {
        // insertion/sorting is done against the hex string notation and not
        // the actual int32 value since the original reference impl generated
        // the mappings via wget/sort -u/sed...
        var runes = new List<string>();

        await foreach (var _line in DownloadAsync(cancellationToken))
        {
            var line = _line;

            var comment = line.IndexOf('#');
            if (comment >= 0)
                line = line.Substring(0, comment);

            if (string.IsNullOrWhiteSpace(line))
                continue;

            var firstRune = line.IndexOf(' ');
            if (firstRune > 0 &&
                line[0] != '0')
            {
                var rune = line.Substring(0, firstRune);
                var index = runes.BinarySearch(rune);
                if (index < 0)
                    runes.Insert(~index, rune);
            }
        }

        var emojis = new List<(int, string)>();
        foreach (var runeString in runes)
        {
            var rune = int.Parse(runeString, NumberStyles.HexNumber);
            emojis.Add((rune, char.ConvertFromUtf32(rune)));
        }
        return emojis;
    }

    const string unicodeEmojiTestsUrl
        = "https://unicode.org/Public/emoji/11.0/emoji-test.txt";

    static async IAsyncEnumerable<string> DownloadAsync(
        [EnumeratorCancellation]CancellationToken cancellationToken)
    {
        var httpClient = new HttpClient();

        var response = await httpClient.GetAsync(
            unicodeEmojiTestsUrl,
            HttpCompletionOption.ResponseHeadersRead,
            cancellationToken);

        response.EnsureSuccessStatusCode();

        var encodingName = response
            .Content
            .Headers
            .ContentType
            ?.CharSet ?? "utf-8";

        var encoding = Encoding.GetEncoding(encodingName);

        var stream = await response.Content.ReadAsStreamAsync();

        var reader = new StreamReader(stream, encoding);

        while (true)
        {
            var line = reader.ReadLine();
            if (line is null)
                break;

            yield return line;
        }
    }
}
